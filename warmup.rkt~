#lang dssl2

# HW1: DSSL2 Warmup
#
# ** You must work on your own for this assignment. **

###
### ACCOUNTS
###

# an Account is either a checking or a saving account
let account_type? = OrC("checking", "savings")

class Account:
    let id
    let type
    let balance

    # Account(nat?, account_type?, num?) -> Account?
    # Constructs an account with the given ID number, account type, and
    # balance. The balance cannot be negative.
    def __init__(self, id, type, balance):
        if balance < 0: error('Account: negative balance')
        if not account_type?(type): error('Account: unknown type')
        self.id = id
        self.type = type
        self.balance = balance

    # .get_balance() -> num?
    def get_balance(self): return self.balance

    # .get_id() -> nat?
    def get_id(self): return self.id

    # .get_type() -> account_type?
    def get_type(self): return self.type

    # .deposit(num?) -> NoneC
    # Deposits `amount` in the account. `amount` must be non-negative.
    def deposit(self, amount):
        pass
#   ^ FILL IN YOUR CODE HERE

    # .withdraw(num?) -> NoneC
    # Withdraws `amount` from the account. `amount` must be non-negative
    # and must not exceed the balance.
    def withdraw(self, amount):
        pass
#   ^ FILL IN YOUR CODE HERE

    # .__eq__(Account?) -> bool?
    # Determines whether `self` and `other` are equal.
    def __eq__(self, other):
        pass
#   ^ FILL IN YOUR CODE HERE

test 'Account#withdraw':
    let account = Account(2, "checking", 32)
    assert account.get_balance() == 32
    account.withdraw(10)
    assert account.get_balance() == 22
    assert_error account.withdraw(-10)

test 'Account#__eq__':
    assert Account(5, "checking", 500) == Account(5, "checking", 500)


# account_transfer(num?, Account?, Account?) -> NoneC
# Transfers the specified amount from the first account to the second.
# That is, it subtracts `amount` from the `from` account’s balance and
# adds `amount` to the `to` account’s balance. `amount` must be non-
# negative.
def account_transfer(amount, from, to):
    pass
#   ^ FILL IN YOUR CODE HERE


###
### CUSTOMERS
###

# Customers have names and bank accounts.
struct customer:
    let name
    let bank_account

# max_account_id(VecC[customer?]) -> nat?
# Find the largest account id used by any of the given customers' accounts.
# Raise an error if no customers are provided.
def max_account_id(customers):
    pass
#   ^ FILL IN YOUR CODE HERE

# open_account(str?, account_type?, VecC[customer?]) -> VecC[customer?]
# Produce a new vector of customers, with a new customer added. That new
# customer has the provided name, and their new account has the given type and
# a balance of 0. The id of the new account should be one more than the current
# maximum, or 1 for the first account created.
def open_account(name, type, customers):
    pass
#   ^ FILL IN YOUR CODE HERE

# check_sharing(VecC[customer?]) -> bool?
# Checks whether any of the given customers share an account.
def check_sharing(customers):
    pass
#   ^ FILL IN YOUR CODE HERE
